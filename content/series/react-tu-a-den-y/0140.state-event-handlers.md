---
layout: series.njk
title: '`state` Và Cách Xử Lý Sự Kiện'
date: 2018-05-04
slug: state-va-cach-xu-ly-su-kien
series: react-tu-a-den-y
author: kcjpop
---

Trong bài viết trước, chúng ta có nhắc đến một trong hai điểm khác biệt cơ bản của functional và class components là class component có hỗ trợ state. Vậy state là gì?

> **Lưu ý**: Kể từ lúc này, khi Ehkoo đề cập đến "component", bạn có thể ngầm hiểu là class component nhé.

State căn bản chỉ là một thuộc tính đặc biệt trong component. Bạn cũng có thể đoán thuộc tính này sẽ có tên là...`this.state`. Mỗi khi state trong component thay đổi, React sẽ cập nhật những thay đổi đó vào cây DOM. Thao tác này được gọi là _rerender_.

Trong ví dụ ở `src/List.jsx`, chúng ta khai báo danh sách các sản phẩm là một biến `products` bên ngoài class. Hãy đem biến này vào state.

```jsx
// src/List.jsx
class List extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      products: [
        { id: 1, name: 'Anak Meat', price: 80 },
        { id: 2, name: 'Birdbeast Egg', price: 20 },
        { id: 3, name: 'Bulette Shank', price: 220 },
        { id: 4, name: 'Daggerquill Breast', price: 60 },
        { id: 5, name: 'Dualhorn Steak', price: 160 },
        { id: 6, name: 'Garula Sirloin', price: 120 },
        { id: 7, name: 'Gighee Ham', price: 30 },
        { id: 8, name: 'Lucian Tomato', price: 200 },
        { id: 9, name: 'Luncheon Meat', price: 100 },
        { id: 10, name: 'Sheep Milk', price: 10 },
      ],
    }
  }

  render() {
    return (
      <table className="ui celled table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody>
          {this.state.products.map(product => (
            <tr key={product.id}>
              <td>{product.id}</td>
              <td>{product.name}</td>
              <td>{product.price} gil</td>
            </tr>
          ))}
        </tbody>
      </table>
    )
  }
}
```

### Cập nhật state

Như đã nói ở trên, React sẽ tự động cập nhật cây DOM mỗi khi dữ liệu trong state thay đổi. Các cập nhật này được thực hiện thông qua phương thức `this.setState(updater, [callback])`.

#### Updater

`updater: Function` là một hàm có dạng `(previousState, props) => stateChanges`, với kết quả trả về chứa các thay đổi của state. Chẳng hạn như:

```js
this.state = { counter: 0, foo: true, bar: 'Hello World' }
this.setState((prevState, props) => {
  return { counter: prevState + 1 }
})
```

Kết quả trả về của hàm `updater` sẽ merge vào `this.state`, do đó bạn chỉ cần trả về những thay đổi cần thiết mà thôi.

```js
console.log(this.state) // { counter: 1, foo: true, bar: 'Hello World' }
```

Thay vì dùng `updater` như một hàm, bạn cũng có thể viết ngắn gọn hơn bằng cách truyền vào một object chứa các thay đổi, giống như:

```js
this.setState({ counter: this.state.counter + 1 })
```

Cách viết này phổ biến hơn nhưng không đem đến tính linh hoạt như với hàm `updater`.

Một vấn đề nữa cũng cần lưu ý là React **KHÔNG** thực hiện merge sâu kết quả của `updater`.

```js
this.state = {
  user: {
    username: 'pitkalong',
    lastLogin: null,
  },
  loading: false,
}

this.setState({ user: { lastLogin: new Date() } })

// Kết quả của this.state lúc này
// { loading: false, user: { lastLogin: '2018-04-01T17:01:53.422Z' } }
```

Như bạn thấy, `this.state.user` đã bị mất `username`. Do đó bạn cần lưu ý một chút khi muốn cập nhật thay đổi lên object.

```js
this.state = {
  user: {
    username: 'pitkalong',
    lastLogin: null,
  },
  loading: false,
}

this.setState({
  // Sử dụng cú pháp spread object của ES7
  user: { ...this.state.user, lastLogin: new Date() },
})

// Kết quả của this.state lúc này
// {
//   loading: false,
//   user: { username: 'pitkalong', lastLogin: '2018-04-01T17:01:53.422Z' }
// }
```

#### callback

`callback: Function` là một hàm sẽ được gọi sau khi các thay đổi đã được cập nhật vào state của component hiện tại. Tham số này là không bắt buộc nhưng đặc biệt hữu ích trong trường hợp bạn cần truy xuất vào state sau khi đã thực hiện các thay đổi. Lý do là vì `setState()` được thực hiện một cách **bất đồng bộ**, và trong một số trường hợp, đoạn code dưới dây sẽ không chạy như mong muốn.

```jsx
setState({ foo: 3 })
console.log(this.state.foo) // Chưa chắc bằng 3
```

React có thể sẽ không cập nhật thay đổi trên cây DOM ngay lập tức mà sẽ kết hợp nhiều kết quả của `setState()` lại để thực hiện một lần cập nhật duy nhất, nhằm nâng cao hiệu suất. Trong trường hợp này, bạn nên dùng `callback` giống như:

```js
this.setState({ foo: 3 }, () => {
  console.log(this.state.foo) // Lúc này this.state.foo đã được cập nhật bằng 3
})
```

Hoặc sử dụng life-cycle `componentDidUpdate()` mà chúng ta sẽ đề cập trong bài viết sau.

### Xử lý sự kiện

Nếu đã từng làm việc với HTML, bạn có thể đã gặp qua đoạn code sau để xử lý sự kiện khi người dùng click vào một button.

```html
<button onclick="alert('hello')">Click me</button>
```

Với React, có một chút khác biệt. Bạn sẽ sử dụng camelCase cho tên sự kiện, và truyền vào tham chiếu đến một hàm.

```jsx
function sayHello() {
  alert('Hello')
}

;<button onClick={sayHello}>Click me</button>
```

Khi sử dụng component, các hàm xử lý sự kiện thường được khai báo là phương thức của class.

```jsx
class HelloWorld extends React.Component {
  constructor(props) {
    super(props)
    this.state = { message: 'Hello' }
    this.sayHello = this.sayHello.bind(this)
  }

  sayHello(e) {
    alert(this.state.message)
  }

  render() {
    return <button onClick={this.sayHello}>Click me</button>
  }
}
```

Bạn có thấy dòng `this.sayHello = this.sayHello.bind(this)` hơi kì kì không? Đó là vì khi `this.sayHello` được gọi là hàm xử lý sự kiện `onClick`, giá trị của`this` bên trong hàm không được tham chiếu đến class `HelloWorld`. Do đó việc gọi đến `.bind` trong hàm dựng là cần thiết. Hoặc bạn có thể dùng đến cú pháp ["class instance field"](https://babeljs.io/docs/plugins/transform-class-properties/) (đã được thiết lập sẵn khi sử dụng `create-react-app`).

```jsx
class HelloWorld extends React.Component {
  state = { message: 'Hello' }

  sayHello = e => {
    alert(this.state.message)
  }

  render() {
    return <button onClick={this.sayHello}>Click me</button>
  }
}
```

_Ehkoo sẽ dùng cú pháp này trở đi cho gọn nhẹ dễ nhìn bạn nhé._

Trong ví dụ ở trên, bạn có thấy tham số `e` của hàm `sayHello` không? Tham số này là một đối tượng của class [`SyntheticEvent`](https://reactjs.org/docs/events.html) của riêng React. Class này tương thích với tiêu chuẩn của W3C nên bạn có thể xem nó giống như [đối tượng Event của trình duyệt](https://developer.mozilla.org/en-US/docs/Web/API/Event) cũng được. Nhìn chung bạn chỉ cần quan tâm đến `e.target/currentTarget`, `e.preventDefault()` và `e.stopPropagation()`.

### Demo: Cập nhật state và xử lý sự kiện

Để hiểu thêm về state và làm quen với xử lý sự kiện trong React, chúng ta hãy viết thêm vài chức năng cho danh sách sản phẩm hôm trước nhé. Trước hết hãy làm một button "rảnh đời", mà khi bạn click vào sẽ nhân đôi giá của các sản phẩm. Chúng ta sẽ viết hàm xử lý sự kiện `onClick` cho button này, trong đó cập nhật state với các sản phẩm đã được thay đổi giá. Bạn có thể tự mình làm thử trước rồi hãy đọc tiếp nhe.

Okay, giải pháp của bạn như thế nào? Ehkoo làm như sau: sửa hàm `render()` của `src/List.jsx` một chút xíu để thêm vào button.

```jsx
  render() {
    return (
      <div>
        <button className="ui primary button" onClick={this.handleDoublePrice}>Double price</button>
        <table className="ui celled table">...</table>
      </div>
    )
  }
```

Hàm `this.handleDoublePrice` được viết như sau:

```js
handleDoublePrice = e => {
  e.preventDefault()
  this.setState(prevState => {
    const products = prevState.products.map(product => ({ ...product, price: product.price * 2 }))
    return { products }
  })
}
```

Chúng ta thay đổi giá trị của mảng `products` trong `this.state` và cập nhật giá của chúng. Khi `this.setState()` được thực hiện xong, React sẽ tiến hành rerender, hiển thị giá mới của sản phẩm. Kết quả sẽ như thế này:

<iframe src="https://codesandbox.io/embed/6zn1j33vjk?view=preview" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

Chúng ta tiếp tục nâng cấp demo ở trên bằng cách thêm vào button cho phép bạn xóa một sản phẩm ra khỏi danh sách. Ehkoo sẽ sửa giao diện lại như thế này:

```jsx
<table className="ui celled table">
  <thead>
    <tr>
      <th>ID</th>
      <th>Name</th>
      <th>Price</th>
      <th />
    </tr>
  </thead>
  <tbody>
    {this.state.products.map(product => (
      <tr key={product.id}>
        <td>{product.id}</td>
        <td>{product.name}</td>
        <td>{product.price} gil</td>
        <td>
          <button className="ui icon red button" onClick={this.handleDeleteProduct}>
            <i className="trash icon" />
          </button>
        </td>
      </tr>
    ))}
  </tbody>
</table>
```

Bạn thử viết phương thức `this.handleDeleteProduct()` xem sao. Khi nào xong hãy đọc tiếp nhé.

Để xóa một sản phẩm ra khỏi danh sách, chúng ta cần biết hoặc là thứ tự của nó trong danh sách, hoặc trong trường hợp này, ID của sản phẩm. Khi có thông tin này rồi, ta có thể áp dụng hàm `.filter()` của Array để loại bỏ sản phẩm ra.

```js
removeProduct = (products, id) => products.filter(product => product.id !== id)
```

Vấn đề là làm sao chúng ta có thể gọi đến hàm `removeProduct()` ở trên trong hàm xử lý sự kiện `onClick`? Bạn có thể viết như sau:

```jsx
handleDeleteProduct = id => {
  const products = this.removeProduct(this.state.products, id)
  this.setState({ products })
}

<button className="ui icon red button" onClick={e => this.handleDeleteProduct(product.id)}>
  <i className="trash icon" />
</button>
```

Bằng cách khai báo một hàm mũi tên và gọi đến `this.handleDeleteProduct`, bạn có thể truyền vào ID của sản phẩm muốn xóa.

<iframe src="https://codesandbox.io/embed/14mq94mnj4?view=preview" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

Cách làm trên tương đối dễ hiểu nhưng lại có vấn đề là trong mỗi lần React rerender, một hàm mũi tên mới lại được tạo ra. Một cách khác là chúng ta sử dụng [`Function.prototype.bind()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).

```jsx
handleDeleteProduct = (id, e) => {
  const products = this.removeProduct(this.state.products, id)
  this.setState({ products })
}

<button className="ui icon red button" onClick={this.handleDeleteProduct.bind(this, product.id)}>
  <i className="trash icon" />
</button>
```

<iframe src="https://codesandbox.io/embed/zr1oqp717p?view=preview" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

> **5 giây quảng cáo**
> Thắc mắc tại sao hàm `handleDeleteProduct()` lại có thêm tham số `e`? Bạn có thể xem thêm bài viết này để hiểu rõ hơn: ABC về `.apply`, `.bind`, và `.call` trong JavaScript.

Ngoài hai cách trên, bạn còn có thể dùng kỹ thuật currying như sau.

```jsx
handleDeleteProduct = id => e => {
  const products = this.removeProduct(this.state.products, id)
  this.setState({ products })
}

<button className="ui icon red button" onClick={this.handleDeleteProduct(product.id)}>
  <i className="trash icon" />
</button>
```

> **Lại thêm 5 giây quảng cáo**
> Đừng bỏ qua bài viết: Lập trình hàm trong JavaScript: Kỹ thuật currying

### Kết

Trong bài viết này chúng ta đã điểm qua:

- `state` bên trong component và cách thay đổi state với `this.setState(updater, [callback])`
- Cách xử lý sự kiện
- Ôn lại về `.bind` và nói sơ qua về kỹ thuật currying

Bài tiếp theo sẽ nhẹ nhàng hơn, chúng ta sẽ nói thêm một chút về hiển thị danh sách và `key`.
