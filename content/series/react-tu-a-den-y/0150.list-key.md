---
layout: series.njk
title: Xử lý danh sách và `key`
date: 2018-05-03
slug: xu-ly-danh-sach-va-key
series: react-tu-a-den-y
author: kcjpop
---

Trong bài viết trước chúng ta đã lướt qua cách hiển thị danh sách (mảng/ array) với React. Bài viết này sẽ nói rõ hơn về cách dùng `key` và những lưu ý khi đặt `key`.

### Hiển thị danh sách

Đối với dữ liệu mảng, chúng ta sẽ dùng phương thức `.map()` để duyệt và hiển thị.

```jsx
function ProductList(props) {
  return (
    <ul>
      {props.products.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  )
}
```

Việc sử dụng `.map()` được xem là "best practice", vì `.map()` sẽ trả về một mảng mới mà không làm ảnh hưởng tới mảng ban đầu. Điều này giúp React phát hiện dữ liệu nào được thay đổi nhanh hơn. Do đó bạn được khuyến khích áp dụng các kỹ thuật thao tác dữ liệu bất biến khi làm việc với React.

Xem thêm: [Tuyệt chiêu đảm bảo tính bất biến trong JavaScript](https://ehkoo.com/bai-viet/array-object-immutability-javascript)

### key

`key` là prop đặc biệt bắt buộc phải có khi hiển thị các phần tử trong mảng. `key` giúp React phát hiện các thay đổi nhanh hơn khi danh sách được thêm/xóa phần tử, hoặc các phần tử được sắp xếp lại. Giá trị của `key` chỉ cần không trùng lắp (unique) với các phần tử anh em của nó, không nhất thiết phải duy nhất trên toàn cây DOM. Thông thường bạn sẽ sử dụng ID của dữ liệu, chẳng hạn như ID người dùng, ID sản phẩm...để làm `key`.

Trong một số trường hợp bất đắc dĩ, bạn có thể sử dụng chỉ mục (index) trong mảng.

```jsx
{
  props.products.map((product, index) => <li key={index}>{product.name}</li>)
}
```

Tuy nhiên, cách làm làm trên không được khuyến khích vì khi bạn sắp xếp lại danh sách, chỉ mục của các phần tử sẽ thay đổi và `key` không giúp ích được gì.

Một lưu ý nữa là `key` phải được khai báo ngay khi bắt đầu duyệt qua mảng.

```jsx
// Sai
function ProductItem(props) {
  return <li key={props.product.id}>{props.product.name}</li>
}

{
  props.products.map(product => <ProductItem product={product} />)
}

// Đúng
function ProductItem(props) {
  return <li>{props.product.name}</li>
}
{
  props.products.map(product => <ProductItem key={props.product.id} product={product} />)
}
```

### Demo: Sắp xếp danh sách

Chúng ta sẽ cập nhật demo trong bài trước bằng cách thêm vào chức năng sắp xếp sản phẩm theo tên, hoặc giá. Kết quả cuối cùng sẽ giống thế này.

<iframe src="https://codesandbox.io/embed/1vj0r4547j?view=preview" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

Bạn có thể click vào tên của cột để sắp xếp danh sách. Thử làm trước khi đọc tiếp nhé.

Để thực hiện chức năng này, trước hết Ehkoo sẽ khai báo hai giá trị `SORT_ASC` (ascending -- theo thứ tự từ trên xuống) và `SORT_DESC` (descending -- theo thứ tự từ dưới lên) và thêm vào thuộc tính `sorter` cho `state`.

```js
const SORT_ASC = 1;
const SORT_DESC = -1;

sorter: { field: null, direction: SORT_ASC }
```

Ý tưởng ở đây là khi click vào một cột, chúng ta sẽ sắp xếp lại `this.state.products` dựa vào tên của cột (`field`) và thứ tự cần thiết. Nếu click vào cột đó lần nữa, thứ tự sắp xếp sẽ được đảo ngược lại. Khi click sang cột khác thì sắp xếp theo giá trị của cột đó trong `this.state.products`. Hàm xử lý sự kiện `onClick` có thể viết như sau:

```js
handleSortProduct = field => e => {
  const { sorter } = this.state

  // Nếu click vào cột khác thì đổi sang sắp xếp theo
  // cột đó
  if (sorter.field !== field)
    return this.setState(prevState => {
      const sorter = { ...prevState.sorter, field }
      const products = this.sortProducts(prevState.products, sorter)
      return { sorter, products }
    })

  // Nếu click vào cùng một cột thì đổi chiều sắp xếp
  const direction = sorter.direction === SORT_ASC ? SORT_DESC : SORT_ASC
  this.setState(prevState => {
    const sorter = { ...prevState.sorter, direction }
    const products = this.sortProducts(prevState.products, sorter)
    return { sorter, products }
  })
}
```

Ở đây chúng ta dùng kỹ thuật currying để truyền giá trị của tên cột vào, đồng thời gắn sự kiện `onClick` vào `th` như sau:

```jsx
<th onClick={this.handleSortProduct("name")}>
  Name
</th>
<th onClick={this.handleSortProduct("price")}>
  Price
</th>
```

Hàm `this.sortProducts(products, sorter)` có thể được cài đặt như sau:

```js
sortProducts = (products, sorter) => {
  return [...products].sort((a, b) => {
    const aValue = a[sorter.field]
    const bValue = b[sorter.field]

    if (sorter.field === 'name') return sorter.direction * aValue.localeCompare(bValue)

    if (sorter.field === 'price') return sorter.direction * (aValue - bValue)
  })
}
```

Để đảm bảo tính bất bất, chúng ta sẽ tạo một bản sao của mảng `products` và tiến hành sắp xếp trên đó. Vì `name` là dữ liệu dạng chuỗi, chúng ta sẽ gọi đến hàm `.localCompare` để sắp xếp, trong khi `price` là dạng số nên có thể tiến hành trừ hai giá trị với nhau. Kết quả trả về của hàm `comparer(a, b)` trong `.sort(comparer)` sẽ quyết định thứ tự sắp xếp:

- `< 0` tức là `a` nhỏ hơn `b`
- `=== 0` tức là `a` bằng `b`
- `> 0` tức là `a` lớn hơn `b`

Bằng cách đặt giá trị của `SORT_ASC = 1`, `SORT_DESC = -1` và nhân với kết quả sắp xếp, chúng ta có thể đảo thứ tự theo ý muốn mà không cần cài đặt hai hàm sắp xếp riêng.

Cuối cùng, chúng ta thêm một icon vào bên cạnh tên cột để biểu thị chiều sắp xếp của dữ liệu:

```jsx
showSortDirection = field => {
  const { sorter } = this.state
  if (sorter.field !== field) return null

  return sorter.direction === SORT_ASC ? (
    <i className="caret down icon" />
  ) : (
    <i className="caret up icon" />
  )
}

<th onClick={this.handleSortProduct("name")}>
  Name {this.showSortDirect('name')}
</th>
<th onClick={this.handleSortProduct("price")}>
  Price {this.showSortDirect('name')}
</th>
```

### Kết

Khi hiển thị dữ liệu mảng, chúng ta cần phải thiết lập giá trị `key`. Giá trị này thường là ID của phần tử trong mảng, và trong trường hợp "cực chẳng đã" chúng ta mới dùng đến chỉ mục (index). `key` chỉ cần không bị trùng lắp với các phần tử anh em của nó, không nhất thiết phải có giá trị độc nhất trong toàn cây DOM.
